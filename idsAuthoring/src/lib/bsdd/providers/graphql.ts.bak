// References
// - bSDD/Documentation/bSDD and GraphQL.md (GraphQL endpoints, examples)
// - bSDD/Documentation/bSDD API.md (REST parity and concepts)
import { gqlFetch } from "../graphqlClient";
import type { BsddProvider } from "../provider";
import type { Library, BsddClass, BsddClassDetail } from "../types";

function extractDictionaryUriFromClassUri(classUri: string): string | null {
  try {
    const u = new URL(classUri);
    const parts = u.pathname.split("/").filter(Boolean);
    const idx = parts.findIndex((p) => p.toLowerCase() === "class");
    if (idx > 0) {
      const base = [u.protocol.replace(":", ""), "", u.host, ...parts.slice(0, idx)].join("/");
      return base;
    }
  } catch {}
  return null;
}

export class GraphqlBsddProvider implements BsddProvider {
  async fetchLibraries(includeTest: boolean): Promise<Library[]> {
    // The public doc doesn't explicitly expose a dictionaries list query.
    // Fall back to REST for now by returning an empty list; callers can merge with REST if desired.
    return [];
  }

  async searchClasses(term: string, dicts: string[], limit = 20): Promise<BsddClass[]> {
    const trimmed = (term || "").trim();
    if (!trimmed || trimmed.length < 2) return [];
    if (!dicts || dicts.length === 0) {
      // GraphQL examples search within a dictionary; without dicts, skip.
      return [];
    }

    // Build a single operation with multiple aliased dictionary queries
    // to search each dictionary in one roundtrip.
    const fields: string[] = [];
    const variables: Record<string, unknown> = {
      searchText: trimmed,
      languageCode: process.env.NEXT_PUBLIC_BSDD_LANG || "en-US",
    };
    dicts.forEach((uri, i) => {
      const alias = `d${i}`;
      const varName = `u${i}`;
      (variables as any)[varName] = uri;
      fields.push(`
        ${alias}: dictionary(uri: $${varName}) {
          uri
          name
          classSearch(searchText: $searchText, languageCode: $languageCode) {
            name
            referenceCode
            uri
            dictionaryUri
          }
        }
      `);
    });

    const query = `query Search($searchText: String!, $languageCode: String!, ${dicts
      .map((_, i) => `$u${i}: String!`)
      .join(", ")}) {
      ${fields.join("\n")}
    }`;

    const data = await gqlFetch<Record<string, { uri: string; name?: string; classSearch: any[] }>>({
      query,
      variables,
    });

    const results: BsddClass[] = [];
    for (const key of Object.keys(data || {})) {
      const block = (data as any)[key];
      const arr = Array.isArray(block?.classSearch) ? block.classSearch : [];
      for (const r of arr.slice(0, limit)) {
        results.push({
          name: String(r.name || r.referenceCode || "Class"),
          referenceCode: r.referenceCode || undefined,
          uri: String(r.uri || ""),
          dictionaryUri: String(r.dictionaryUri || block?.uri || ""),
          dictionaryName: block?.name,
        });
      }
    }
    return results;
  }

  async getClass(uri: string): Promise<BsddClassDetail | null> {
    const dictUri = extractDictionaryUriFromClassUri(uri);
    if (!dictUri) return null;
    const query = `query ($dictionaryUri: String!, $uri: String!, $languageCode: String!) {
      dictionary(uri: $dictionaryUri) {
        uri
        class(uri: $uri, languageCode: $languageCode, includeChildren: false) {
          name
          referenceCode
          uri
        }
      }
    }`;
    const data = await gqlFetch<{ dictionary?: { class?: any } }>({
      query,
      variables: { dictionaryUri: dictUri, uri, languageCode: process.env.NEXT_PUBLIC_BSDD_LANG || "en-US" },
    });
    const c = data?.dictionary?.class;
    if (!c) return null;
    return {
      name: String(c.name || c.referenceCode || "Class"),
      referenceCode: c.referenceCode || undefined,
      uri: String(c.uri || uri),
      dictionaryUri: dictUri,
      description: undefined,
    };
  }
}

